<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Memory Automaton: Rainbow AliveCount</title>
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    /* Basic reset and styling */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: "Helvetica Neue", Arial, sans-serif;
      color: #fff;        /* White text for main page content */
      background: #000;   /* Black page background */
      overflow-x: hidden;  /* Hide horizontal scrollbar only */
      overflow-y: auto;    /* Allow vertical scrolling */
    }

    .content {
      position: relative;
      z-index: 1;

      /* Slightly wider for larger screens */
      max-width: 700px;

      /* 25% bigger margins & padding than before */
      margin: 2.5rem auto;
      padding: 2.5rem 1.5rem 4rem;

      /* Darker background panel for clarity */
      background: rgba(0,0,0,0.75);
      border-radius: 8px;
    }

    /* For smaller screens, preserve 5% margins on each side */
    @media (max-width: 768px) {
      .content {
        margin: 2.5rem 5%;
      }
    }

    h1 {
      /* Slightly tighter spacing */
      font-size: 3rem;
      margin-bottom: 1.2rem;
      text-align: center;
      line-height: 1.2;
    }

    p {
      /* Tighter line spacing */
      font-size: 1.25rem;
      line-height: 1.5;
      margin-bottom: 1rem;
    }

    @media (min-width: 768px) {
      h1 {
        font-size: 3.6rem;
      }
      p {
        font-size: 1.4rem;
      }
    }

    /* The canvas sits behind everything */
    #automatonCanvas {
      position: fixed;
      top: 0;
      left: 0;
      z-index: 0;
    }
  </style>
</head>

<body>

  <div class="content">
    <h1 id="lets-remember-memory-intelligence">Let’s remember: memory ~
intelligence</h1>
<p>What’s the difference between <strong>recognizing</strong> a catchy
tune and <strong>baking</strong> a perfect loaf of bread? The first
demands <strong>pattern matching</strong>—you hear the melody and it
clicks. The second needs <strong>memory</strong> at every step—waiting
for dough to rise, adjusting oven temperatures, and making sure each
ingredient is added in the right order. Without memory, the chain of
logical steps falls apart.</p>
<p>This <strong>memory-as-computation</strong> principle repeats
everywhere. Biology taught us early: cells look like pure
<em>parallelism</em>, yet they achieve sequential logic with molecular
memory systems—like CRISPR storing a <em>chronological record</em> of
viral attacks. Humanity advanced not by growing bigger brains, but by
<strong>inventing memory technologies</strong>, from oral traditions to
writing and modern computing. Each leap hinged on being able to
<strong>preserve</strong> what was already figured out.</p>
<p>Modern <strong>large language models</strong> (LLMs) expose the same
truth. They’re brilliant at pattern matching (absorbing billions of
words) but struggle with <em>multi-step reasoning</em> unless they brute
force <em>chain-of-thought</em>, incurring huge compute costs. OpenAI’s
“o3” system famously solved tough tasks but spent <strong>over a million
dollars</strong> in “reasoning time.” Why so costly? Because robust
memory is <em>expensive</em> for parallel architectures that weren’t
built to hold on to a state across many steps.</p>
<p>In the end, <strong>memory</strong> is what makes <strong>universal
computation</strong> possible—crossing from “What do I see right now?”
to “How do I follow a sequence of steps to reach a conclusion?” That’s
why next-gen AI efforts focus less on sheer model size and more on how
to systematically <em>store</em> and <em>retrieve</em> partial results.
If intelligence is a <em>fire</em>, then <strong>memory is the
oxygen</strong> that keeps it burning. And that simple shift—from
ephemeral pattern-matcher to faithful record-keeper—lies at the heart of
real reasoning, from cells to chatbots to civilization itself.</p>
  </div>

<!-- p5.js from CDN -->
<script src="https://cdn.jsdelivr.net/npm/p5@1.4.2/lib/p5.min.js"></script>
<script>
/*
  Memory Automaton w/ Rainbow AliveCount (All Dead = Black)

  Changes:
    - All dead cells => black (0,0,0), regardless of mem.
    - If alive => pick from rainbow palette based on aliveCount.
    - If aliveCount=0 => no digit displayed (so first time doesn't show "0").
    - Text panel is bigger & darker.

  Each cell has:
    state (0/1),
    mem (0/1),
    aliveCount (0..9),
    colorVal = {r, g, b} ~ current displayed color (fades)
*/

// Cell geometry
let cellSize = 14;
let cols, rows;

// Each cell: { state, mem, aliveCount, colorVal: {r, g, b} }
let grid = [];

// Update speeds
let frameRateVal    = 10;
let updatesPerFrame = 20;
let patchSize       = 3;

// We define a subdued rainbow palette for aliveCount=0..9
const rainbowPalette = [
  { r: 160, g: 40,  b: 40  }, // 0  (dull red)
  { r: 180, g: 80,  b: 40  }, // 1  (soft orange)
  { r: 190, g: 140, b: 50  }, // 2  (soft yellow)
  { r: 90,  g: 160, b: 70  }, // 3  (pastel green)
  { r: 70,  g: 160, b: 140 }, // 4  (teal)
  { r: 70,  g: 100, b: 180 }, // 5  (blue)
  { r: 110, g: 70,  b: 180 }, // 6  (purple)
  { r: 150, g: 60,  b: 180 }, // 7  (lavender)
  { r: 180, g: 60,  b: 120 }, // 8  (magenta)
  { r: 180, g: 60,  b: 80  }  // 9  (pinkish-red)
];

// All dead cells => black
const blackColor = { r: 0, g: 0, b: 0 };

// Lerp rate for color transitions
const colorLerpRate = 0.08;

function setup() {
  createCanvas(windowWidth, windowHeight).id("automatonCanvas");
  frameRate(frameRateVal);

  cols = floor(width / cellSize);
  rows = floor(height / cellSize);

  textAlign(CENTER, CENTER);
  textSize(cellSize * 0.5);
  noStroke();

  // Initialize the grid
  for (let r = 0; r < rows; r++) {
    grid[r] = [];
    for (let c = 0; c < cols; c++) {
      let isAlive = random() < 0.15 ? 1 : 0;
      // Start color: either rainbowPalette[0] or black
      let colorStart = isAlive ? rainbowPalette[0] : blackColor;
      grid[r][c] = {
        state:      isAlive,
        mem:        0,
        aliveCount: 0,
        everAlive:  isAlive, // true if starting alive
        colorVal:   { r: colorStart.r, g: colorStart.g, b: colorStart.b }
      };
    }
  }
}

function draw() {
  // Semi-opaque black background => clears old frames gently
  background(0, 100);

  // Update random patches
  for (let i = 0; i < updatesPerFrame; i++) {
    let rr = floor(random(rows));
    let cc = floor(random(cols));
    updatePatch(rr, cc, patchSize);
  }

  // Render each cell
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let cell = grid[r][c];
      let target = getTargetColor(cell);

      // Smoothly lerp colorVal => target
      cell.colorVal.r = lerp(cell.colorVal.r, target.r, colorLerpRate);
      cell.colorVal.g = lerp(cell.colorVal.g, target.g, colorLerpRate);
      cell.colorVal.b = lerp(cell.colorVal.b, target.b, colorLerpRate);

      // Fill with the updated color
      fill(cell.colorVal.r, cell.colorVal.g, cell.colorVal.b);
      rect(c * cellSize, r * cellSize, cellSize, cellSize);

      // Show digit if aliveCount > 0 or if it's wrapped back to 0 (not first time)
      if (cell.aliveCount > 0 || (cell.aliveCount === 0 && cell.everAlive)) {
        fill(cell.colorVal.r * 0.7, cell.colorVal.g * 0.7, cell.colorVal.b * 0.7);
        text(
          cell.aliveCount,
          c * cellSize + cellSize / 2,
          r * cellSize + cellSize / 2
        );
      }
    }
  }
}

// Decide the target color for a cell
function getTargetColor(cell) {
  // If alive => pick from rainbowPalette based on aliveCount
  if (cell.state === 1) {
    return rainbowPalette[cell.aliveCount];
  }
  // Otherwise (dead) => black
  return blackColor;
}

// Update a patch of cells
function updatePatch(row, col, size) {
  for (let rr = row; rr < row + size; rr++) {
    for (let cc = col; cc < col + size; cc++) {
      if (rr < 0 || rr >= rows || cc < 0 || cc >= cols) continue;
      updateCell(rr, cc);
    }
  }
}

// Single-cell update logic
function updateCell(r, c) {
  let cell = grid[r][c];

  function safeGet(rr, cc) {
    if (rr < 0 || rr >= rows || cc < 0 || cc >= cols) return 0;
    return grid[rr][cc].state;
  }

  let left  = safeGet(r, c - 1);
  let self  = cell.state;
  let right = safeGet(r, c + 1);

  let newMem = cell.mem || self;  // if ever alive => mem=1

  // Standard "Rule 110" bits => index 0..7
  let neighborhood = (left << 2) | (self << 1) | right;
  let rule110 = [0,1,1,1,1,0,1,0];
  let outcome = rule110[ neighborhood ];

  // Twist: if mem=1 && neighborhood=2 => flip outcome
  if (newMem === 1 && neighborhood === 2) {
    outcome = outcome === 1 ? 0 : 1;
  }

  // If cell is alive => increment aliveCount (wrap at 9)
  let newCount = cell.aliveCount;
  if (outcome === 1) {
    newCount = (newCount + 1) % 10;
    cell.everAlive = true; // Mark as having been alive
  }

  cell.state      = outcome;
  cell.mem        = newMem;
  cell.aliveCount = newCount;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  cols = floor(width / cellSize);
  rows = floor(height / cellSize);

  textSize(cellSize * 0.5);

  // Rebuild grid, preserving old data
  let newGrid = [];
  for (let r = 0; r < rows; r++) {
    newGrid[r] = [];
    for (let c = 0; c < cols; c++) {
      if (grid[r] && grid[r][c]) {
        let old = grid[r][c];
        newGrid[r][c] = {
          state:      old.state,
          mem:        old.mem,
          aliveCount: old.aliveCount,
          everAlive:  old.everAlive,
          // copy over colorVal
          colorVal:   { 
            r: old.colorVal.r, 
            g: old.colorVal.g, 
            b: old.colorVal.b 
          }
        };
      } else {
        // If newly created cell is outside old range
        let isAlive = random() < 0.15 ? 1 : 0;
        let colorStart = isAlive ? rainbowPalette[0] : blackColor;
        newGrid[r][c] = {
          state:      isAlive,
          mem:        0,
          aliveCount: 0,
          everAlive:  isAlive,
          colorVal:   { r: colorStart.r, g: colorStart.g, b: colorStart.b }
        };
      }
    }
  }
  grid = newGrid;
}

// Basic 1D linear interpolation
function lerp(start, end, amt) {
  return (1 - amt) * start + amt * end;
}
</script>
</body>
</html>
